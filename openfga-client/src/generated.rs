// This file is auto-generated by client-builder. Do not edit manually.
// Run `cargo build -p client-builder` to regenerate.

// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationModel {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub type_definitions: ::prost::alloc::vec::Vec<TypeDefinition>,
    #[prost(map = "string, message", tag = "4")]
    pub conditions: ::std::collections::HashMap<::prost::alloc::string::String, Condition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypeDefinition {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub relations: ::std::collections::HashMap<::prost::alloc::string::String, Userset>,
    /// A map whose keys are the name of the relation and whose value is the Metadata for that relation.
    /// It also holds information around the module name and source file if this model was constructed
    /// from a modular model.
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<Metadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rewrite: ::core::option::Option<Userset>,
    #[prost(message, optional, tag = "3")]
    pub type_info: ::core::option::Option<RelationTypeInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationTypeInfo {
    #[prost(message, repeated, tag = "1")]
    pub directly_related_user_types: ::prost::alloc::vec::Vec<RelationReference>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(map = "string, message", tag = "1")]
    pub relations: ::std::collections::HashMap<::prost::alloc::string::String, RelationMetadata>,
    #[prost(string, tag = "2")]
    pub module: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source_info: ::core::option::Option<SourceInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceInfo {
    #[prost(string, tag = "1")]
    pub file: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationMetadata {
    #[prost(message, repeated, tag = "1")]
    pub directly_related_user_types: ::prost::alloc::vec::Vec<RelationReference>,
    #[prost(string, tag = "2")]
    pub module: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source_info: ::core::option::Option<SourceInfo>,
}
/// RelationReference represents a relation of a particular object type (e.g. 'document#viewer').
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationReference {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// The name of a condition that is enforced over the allowed relation.
    #[prost(string, tag = "4")]
    pub condition: ::prost::alloc::string::String,
    #[prost(oneof = "relation_reference::RelationOrWildcard", tags = "2, 3")]
    pub relation_or_wildcard: ::core::option::Option<relation_reference::RelationOrWildcard>,
}
/// Nested message and enum types in `RelationReference`.
pub mod relation_reference {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RelationOrWildcard {
        #[prost(string, tag = "2")]
        Relation(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Wildcard(super::Wildcard),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Wildcard {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Usersets {
    #[prost(message, repeated, tag = "1")]
    pub child: ::prost::alloc::vec::Vec<Userset>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Difference {
    #[prost(message, optional, boxed, tag = "1")]
    pub base: ::core::option::Option<::prost::alloc::boxed::Box<Userset>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub subtract: ::core::option::Option<::prost::alloc::boxed::Box<Userset>>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Userset {
    #[prost(oneof = "userset::Userset", tags = "1, 2, 3, 4, 5, 6")]
    pub userset: ::core::option::Option<userset::Userset>,
}
/// Nested message and enum types in `Userset`.
pub mod userset {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Userset {
        #[prost(message, tag = "1")]
        This(super::DirectUserset),
        #[prost(message, tag = "2")]
        ComputedUserset(super::ObjectRelation),
        #[prost(message, tag = "3")]
        TupleToUserset(super::TupleToUserset),
        #[prost(message, tag = "4")]
        Union(super::Usersets),
        #[prost(message, tag = "5")]
        Intersection(super::Usersets),
        #[prost(message, tag = "6")]
        Difference(::prost::alloc::boxed::Box<super::Difference>),
    }
}
/// A DirectUserset is a sentinel message for referencing
/// the direct members specified by an object/relation mapping.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DirectUserset {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectRelation {
    #[prost(string, tag = "1")]
    pub object: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputedUserset {
    #[prost(string, tag = "1")]
    pub relation: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleToUserset {
    /// The target object/relation
    #[prost(message, optional, tag = "1")]
    pub tupleset: ::core::option::Option<ObjectRelation>,
    #[prost(message, optional, tag = "2")]
    pub computed_userset: ::core::option::Option<ObjectRelation>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    /// A unique name for the condition
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A Google CEL expression, expressed as a string.
    #[prost(string, tag = "2")]
    pub expression: ::prost::alloc::string::String,
    /// A map of parameter names to the parameter's defined type reference.
    #[prost(map = "string, message", tag = "3")]
    pub parameters:
        ::std::collections::HashMap<::prost::alloc::string::String, ConditionParamTypeRef>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ConditionMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionMetadata {
    #[prost(string, tag = "1")]
    pub module: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub source_info: ::core::option::Option<SourceInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConditionParamTypeRef {
    #[prost(enumeration = "condition_param_type_ref::TypeName", tag = "1")]
    pub type_name: i32,
    #[prost(message, repeated, tag = "2")]
    pub generic_types: ::prost::alloc::vec::Vec<ConditionParamTypeRef>,
}
/// Nested message and enum types in `ConditionParamTypeRef`.
pub mod condition_param_type_ref {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TypeName {
        Unspecified = 0,
        Any = 1,
        Bool = 2,
        String = 3,
        Int = 4,
        Uint = 5,
        Double = 6,
        Duration = 7,
        Timestamp = 8,
        Map = 9,
        List = 10,
        Ipaddress = 11,
    }
    impl TypeName {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_NAME_UNSPECIFIED",
                Self::Any => "TYPE_NAME_ANY",
                Self::Bool => "TYPE_NAME_BOOL",
                Self::String => "TYPE_NAME_STRING",
                Self::Int => "TYPE_NAME_INT",
                Self::Uint => "TYPE_NAME_UINT",
                Self::Double => "TYPE_NAME_DOUBLE",
                Self::Duration => "TYPE_NAME_DURATION",
                Self::Timestamp => "TYPE_NAME_TIMESTAMP",
                Self::Map => "TYPE_NAME_MAP",
                Self::List => "TYPE_NAME_LIST",
                Self::Ipaddress => "TYPE_NAME_IPADDRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_NAME_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_NAME_ANY" => Some(Self::Any),
                "TYPE_NAME_BOOL" => Some(Self::Bool),
                "TYPE_NAME_STRING" => Some(Self::String),
                "TYPE_NAME_INT" => Some(Self::Int),
                "TYPE_NAME_UINT" => Some(Self::Uint),
                "TYPE_NAME_DOUBLE" => Some(Self::Double),
                "TYPE_NAME_DURATION" => Some(Self::Duration),
                "TYPE_NAME_TIMESTAMP" => Some(Self::Timestamp),
                "TYPE_NAME_MAP" => Some(Self::Map),
                "TYPE_NAME_LIST" => Some(Self::List),
                "TYPE_NAME_IPADDRESS" => Some(Self::Ipaddress),
                _ => None,
            }
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationErrorMessageResponse {
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnauthenticatedResponse {
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnprocessableContentMessageResponse {
    #[prost(enumeration = "UnprocessableContentErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InternalErrorMessageResponse {
    #[prost(enumeration = "InternalErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathUnknownErrorMessageResponse {
    #[prost(enumeration = "NotFoundErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbortedMessageResponse {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorMessageRequest {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForbiddenResponse {
    #[prost(enumeration = "AuthErrorCode", tag = "1")]
    pub code: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AuthErrorCode {
    NoAuthError = 0,
    AuthFailedInvalidSubject = 1001,
    AuthFailedInvalidAudience = 1002,
    AuthFailedInvalidIssuer = 1003,
    InvalidClaims = 1004,
    AuthFailedInvalidBearerToken = 1005,
    BearerTokenMissing = 1010,
    Unauthenticated = 1500,
    Forbidden = 1600,
}
impl AuthErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoAuthError => "no_auth_error",
            Self::AuthFailedInvalidSubject => "auth_failed_invalid_subject",
            Self::AuthFailedInvalidAudience => "auth_failed_invalid_audience",
            Self::AuthFailedInvalidIssuer => "auth_failed_invalid_issuer",
            Self::InvalidClaims => "invalid_claims",
            Self::AuthFailedInvalidBearerToken => "auth_failed_invalid_bearer_token",
            Self::BearerTokenMissing => "bearer_token_missing",
            Self::Unauthenticated => "unauthenticated",
            Self::Forbidden => "forbidden",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "no_auth_error" => Some(Self::NoAuthError),
            "auth_failed_invalid_subject" => Some(Self::AuthFailedInvalidSubject),
            "auth_failed_invalid_audience" => Some(Self::AuthFailedInvalidAudience),
            "auth_failed_invalid_issuer" => Some(Self::AuthFailedInvalidIssuer),
            "invalid_claims" => Some(Self::InvalidClaims),
            "auth_failed_invalid_bearer_token" => Some(Self::AuthFailedInvalidBearerToken),
            "bearer_token_missing" => Some(Self::BearerTokenMissing),
            "unauthenticated" => Some(Self::Unauthenticated),
            "forbidden" => Some(Self::Forbidden),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    NoError = 0,
    ValidationError = 2000,
    AuthorizationModelNotFound = 2001,
    AuthorizationModelResolutionTooComplex = 2002,
    InvalidWriteInput = 2003,
    CannotAllowDuplicateTuplesInOneRequest = 2004,
    CannotAllowDuplicateTypesInOneRequest = 2005,
    CannotAllowMultipleReferencesToOneRelation = 2006,
    InvalidContinuationToken = 2007,
    InvalidTupleSet = 2008,
    InvalidCheckInput = 2009,
    InvalidExpandInput = 2010,
    UnsupportedUserSet = 2011,
    InvalidObjectFormat = 2012,
    WriteFailedDueToInvalidInput = 2017,
    AuthorizationModelAssertionsNotFound = 2018,
    LatestAuthorizationModelNotFound = 2020,
    TypeNotFound = 2021,
    RelationNotFound = 2022,
    EmptyRelationDefinition = 2023,
    InvalidUser = 2025,
    InvalidTuple = 2027,
    UnknownRelation = 2028,
    StoreIdInvalidLength = 2030,
    AssertionsTooManyItems = 2033,
    IdTooLong = 2034,
    AuthorizationModelIdTooLong = 2036,
    TupleKeyValueNotSpecified = 2037,
    TupleKeysTooManyOrTooFewItems = 2038,
    PageSizeInvalid = 2039,
    ParamMissingValue = 2040,
    DifferenceBaseMissingValue = 2041,
    SubtractBaseMissingValue = 2042,
    ObjectTooLong = 2043,
    RelationTooLong = 2044,
    TypeDefinitionsTooFewItems = 2045,
    TypeInvalidLength = 2046,
    TypeInvalidPattern = 2047,
    RelationsTooFewItems = 2048,
    RelationsTooLong = 2049,
    RelationsInvalidPattern = 2050,
    ObjectInvalidPattern = 2051,
    QueryStringTypeContinuationTokenMismatch = 2052,
    ExceededEntityLimit = 2053,
    InvalidContextualTuple = 2054,
    DuplicateContextualTuple = 2055,
    InvalidAuthorizationModel = 2056,
    UnsupportedSchemaVersion = 2057,
    Cancelled = 2058,
    InvalidStartTime = 2059,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoError => "no_error",
            Self::ValidationError => "validation_error",
            Self::AuthorizationModelNotFound => "authorization_model_not_found",
            Self::AuthorizationModelResolutionTooComplex => {
                "authorization_model_resolution_too_complex"
            }
            Self::InvalidWriteInput => "invalid_write_input",
            Self::CannotAllowDuplicateTuplesInOneRequest => {
                "cannot_allow_duplicate_tuples_in_one_request"
            }
            Self::CannotAllowDuplicateTypesInOneRequest => {
                "cannot_allow_duplicate_types_in_one_request"
            }
            Self::CannotAllowMultipleReferencesToOneRelation => {
                "cannot_allow_multiple_references_to_one_relation"
            }
            Self::InvalidContinuationToken => "invalid_continuation_token",
            Self::InvalidTupleSet => "invalid_tuple_set",
            Self::InvalidCheckInput => "invalid_check_input",
            Self::InvalidExpandInput => "invalid_expand_input",
            Self::UnsupportedUserSet => "unsupported_user_set",
            Self::InvalidObjectFormat => "invalid_object_format",
            Self::WriteFailedDueToInvalidInput => "write_failed_due_to_invalid_input",
            Self::AuthorizationModelAssertionsNotFound => {
                "authorization_model_assertions_not_found"
            }
            Self::LatestAuthorizationModelNotFound => "latest_authorization_model_not_found",
            Self::TypeNotFound => "type_not_found",
            Self::RelationNotFound => "relation_not_found",
            Self::EmptyRelationDefinition => "empty_relation_definition",
            Self::InvalidUser => "invalid_user",
            Self::InvalidTuple => "invalid_tuple",
            Self::UnknownRelation => "unknown_relation",
            Self::StoreIdInvalidLength => "store_id_invalid_length",
            Self::AssertionsTooManyItems => "assertions_too_many_items",
            Self::IdTooLong => "id_too_long",
            Self::AuthorizationModelIdTooLong => "authorization_model_id_too_long",
            Self::TupleKeyValueNotSpecified => "tuple_key_value_not_specified",
            Self::TupleKeysTooManyOrTooFewItems => "tuple_keys_too_many_or_too_few_items",
            Self::PageSizeInvalid => "page_size_invalid",
            Self::ParamMissingValue => "param_missing_value",
            Self::DifferenceBaseMissingValue => "difference_base_missing_value",
            Self::SubtractBaseMissingValue => "subtract_base_missing_value",
            Self::ObjectTooLong => "object_too_long",
            Self::RelationTooLong => "relation_too_long",
            Self::TypeDefinitionsTooFewItems => "type_definitions_too_few_items",
            Self::TypeInvalidLength => "type_invalid_length",
            Self::TypeInvalidPattern => "type_invalid_pattern",
            Self::RelationsTooFewItems => "relations_too_few_items",
            Self::RelationsTooLong => "relations_too_long",
            Self::RelationsInvalidPattern => "relations_invalid_pattern",
            Self::ObjectInvalidPattern => "object_invalid_pattern",
            Self::QueryStringTypeContinuationTokenMismatch => {
                "query_string_type_continuation_token_mismatch"
            }
            Self::ExceededEntityLimit => "exceeded_entity_limit",
            Self::InvalidContextualTuple => "invalid_contextual_tuple",
            Self::DuplicateContextualTuple => "duplicate_contextual_tuple",
            Self::InvalidAuthorizationModel => "invalid_authorization_model",
            Self::UnsupportedSchemaVersion => "unsupported_schema_version",
            Self::Cancelled => "cancelled",
            Self::InvalidStartTime => "invalid_start_time",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "no_error" => Some(Self::NoError),
            "validation_error" => Some(Self::ValidationError),
            "authorization_model_not_found" => Some(Self::AuthorizationModelNotFound),
            "authorization_model_resolution_too_complex" => {
                Some(Self::AuthorizationModelResolutionTooComplex)
            }
            "invalid_write_input" => Some(Self::InvalidWriteInput),
            "cannot_allow_duplicate_tuples_in_one_request" => {
                Some(Self::CannotAllowDuplicateTuplesInOneRequest)
            }
            "cannot_allow_duplicate_types_in_one_request" => {
                Some(Self::CannotAllowDuplicateTypesInOneRequest)
            }
            "cannot_allow_multiple_references_to_one_relation" => {
                Some(Self::CannotAllowMultipleReferencesToOneRelation)
            }
            "invalid_continuation_token" => Some(Self::InvalidContinuationToken),
            "invalid_tuple_set" => Some(Self::InvalidTupleSet),
            "invalid_check_input" => Some(Self::InvalidCheckInput),
            "invalid_expand_input" => Some(Self::InvalidExpandInput),
            "unsupported_user_set" => Some(Self::UnsupportedUserSet),
            "invalid_object_format" => Some(Self::InvalidObjectFormat),
            "write_failed_due_to_invalid_input" => Some(Self::WriteFailedDueToInvalidInput),
            "authorization_model_assertions_not_found" => {
                Some(Self::AuthorizationModelAssertionsNotFound)
            }
            "latest_authorization_model_not_found" => Some(Self::LatestAuthorizationModelNotFound),
            "type_not_found" => Some(Self::TypeNotFound),
            "relation_not_found" => Some(Self::RelationNotFound),
            "empty_relation_definition" => Some(Self::EmptyRelationDefinition),
            "invalid_user" => Some(Self::InvalidUser),
            "invalid_tuple" => Some(Self::InvalidTuple),
            "unknown_relation" => Some(Self::UnknownRelation),
            "store_id_invalid_length" => Some(Self::StoreIdInvalidLength),
            "assertions_too_many_items" => Some(Self::AssertionsTooManyItems),
            "id_too_long" => Some(Self::IdTooLong),
            "authorization_model_id_too_long" => Some(Self::AuthorizationModelIdTooLong),
            "tuple_key_value_not_specified" => Some(Self::TupleKeyValueNotSpecified),
            "tuple_keys_too_many_or_too_few_items" => Some(Self::TupleKeysTooManyOrTooFewItems),
            "page_size_invalid" => Some(Self::PageSizeInvalid),
            "param_missing_value" => Some(Self::ParamMissingValue),
            "difference_base_missing_value" => Some(Self::DifferenceBaseMissingValue),
            "subtract_base_missing_value" => Some(Self::SubtractBaseMissingValue),
            "object_too_long" => Some(Self::ObjectTooLong),
            "relation_too_long" => Some(Self::RelationTooLong),
            "type_definitions_too_few_items" => Some(Self::TypeDefinitionsTooFewItems),
            "type_invalid_length" => Some(Self::TypeInvalidLength),
            "type_invalid_pattern" => Some(Self::TypeInvalidPattern),
            "relations_too_few_items" => Some(Self::RelationsTooFewItems),
            "relations_too_long" => Some(Self::RelationsTooLong),
            "relations_invalid_pattern" => Some(Self::RelationsInvalidPattern),
            "object_invalid_pattern" => Some(Self::ObjectInvalidPattern),
            "query_string_type_continuation_token_mismatch" => {
                Some(Self::QueryStringTypeContinuationTokenMismatch)
            }
            "exceeded_entity_limit" => Some(Self::ExceededEntityLimit),
            "invalid_contextual_tuple" => Some(Self::InvalidContextualTuple),
            "duplicate_contextual_tuple" => Some(Self::DuplicateContextualTuple),
            "invalid_authorization_model" => Some(Self::InvalidAuthorizationModel),
            "unsupported_schema_version" => Some(Self::UnsupportedSchemaVersion),
            "cancelled" => Some(Self::Cancelled),
            "invalid_start_time" => Some(Self::InvalidStartTime),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnprocessableContentErrorCode {
    NoThrottledErrorCode = 0,
    ThrottledTimeoutError = 3500,
}
impl UnprocessableContentErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoThrottledErrorCode => "no_throttled_error_code",
            Self::ThrottledTimeoutError => "throttled_timeout_error",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "no_throttled_error_code" => Some(Self::NoThrottledErrorCode),
            "throttled_timeout_error" => Some(Self::ThrottledTimeoutError),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InternalErrorCode {
    NoInternalError = 0,
    InternalError = 4000,
    DeadlineExceeded = 4004,
    AlreadyExists = 4005,
    ResourceExhausted = 4006,
    FailedPrecondition = 4007,
    Aborted = 4008,
    OutOfRange = 4009,
    Unavailable = 4010,
    DataLoss = 4011,
}
impl InternalErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoInternalError => "no_internal_error",
            Self::InternalError => "internal_error",
            Self::DeadlineExceeded => "deadline_exceeded",
            Self::AlreadyExists => "already_exists",
            Self::ResourceExhausted => "resource_exhausted",
            Self::FailedPrecondition => "failed_precondition",
            Self::Aborted => "aborted",
            Self::OutOfRange => "out_of_range",
            Self::Unavailable => "unavailable",
            Self::DataLoss => "data_loss",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "no_internal_error" => Some(Self::NoInternalError),
            "internal_error" => Some(Self::InternalError),
            "deadline_exceeded" => Some(Self::DeadlineExceeded),
            "already_exists" => Some(Self::AlreadyExists),
            "resource_exhausted" => Some(Self::ResourceExhausted),
            "failed_precondition" => Some(Self::FailedPrecondition),
            "aborted" => Some(Self::Aborted),
            "out_of_range" => Some(Self::OutOfRange),
            "unavailable" => Some(Self::Unavailable),
            "data_loss" => Some(Self::DataLoss),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotFoundErrorCode {
    NoNotFoundError = 0,
    UndefinedEndpoint = 5000,
    StoreIdNotFound = 5002,
    Unimplemented = 5004,
}
impl NotFoundErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoNotFoundError => "no_not_found_error",
            Self::UndefinedEndpoint => "undefined_endpoint",
            Self::StoreIdNotFound => "store_id_not_found",
            Self::Unimplemented => "unimplemented",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "no_not_found_error" => Some(Self::NoNotFoundError),
            "undefined_endpoint" => Some(Self::UndefinedEndpoint),
            "store_id_not_found" => Some(Self::StoreIdNotFound),
            "unimplemented" => Some(Self::Unimplemented),
            _ => None,
        }
    }
}
/// Object represents an OpenFGA Object.
///
/// An Object is composed of a type and identifier (e.g. 'document:1')
///
/// See <https://openfga.dev/docs/concepts#what-is-an-object>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Object {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// User.
///
/// Represents any possible value for a user (subject or principal). Can be a:
/// - Specific user object e.g.: 'user:will', 'folder:marketing', 'org:contoso', ...)
/// - Specific userset (e.g. 'group:engineering#member')
/// - Public-typed wildcard (e.g. 'user:*')
///
/// See <https://openfga.dev/docs/concepts#what-is-a-user>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(oneof = "user::User", tags = "1, 2, 3")]
    pub user: ::core::option::Option<user::User>,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum User {
        #[prost(message, tag = "1")]
        Object(super::Object),
        #[prost(message, tag = "2")]
        Userset(super::UsersetUser),
        #[prost(message, tag = "3")]
        Wildcard(super::TypedWildcard),
    }
}
/// Userset.
///
/// A set or group of users, represented in the `<type>:<id>#<relation>` format
///
/// `group:fga#member` represents all members of group FGA, not to be confused by `group:fga` which represents the group itself as a specific object.
///
/// See: <https://openfga.dev/docs/modeling/building-blocks/usersets#what-is-a-userset>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsersetUser {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub relation: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationshipCondition {
    /// A reference (by name) of the relationship condition defined in the authorization model.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Additional context/data to persist along with the condition.
    /// The keys must match the parameters defined by the condition, and the value types must
    /// match the parameter type definitions.
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleKeyWithoutCondition {
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub object: ::prost::alloc::string::String,
}
/// Type bound public access.
///
/// Normally represented using the `<type>:*` syntax
///
/// `employee:*` represents every object of type `employee`, including those not currently present in the system
///
/// See <https://openfga.dev/docs/concepts#what-is-type-bound-public-access>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TypedWildcard {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleKey {
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub object: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub condition: ::core::option::Option<RelationshipCondition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tuple {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<TupleKey>,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleKeys {
    #[prost(message, repeated, tag = "1")]
    pub tuple_keys: ::prost::alloc::vec::Vec<TupleKey>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContextualTupleKeys {
    #[prost(message, repeated, tag = "1")]
    pub tuple_keys: ::prost::alloc::vec::Vec<TupleKey>,
}
/// A UsersetTree contains the result of an Expansion.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsersetTree {
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<userset_tree::Node>,
}
/// Nested message and enum types in `UsersetTree`.
pub mod userset_tree {
    /// A leaf node contains either
    /// - a set of users (which may be individual users, or usersets
    ///    referencing other relations)
    /// - a computed node, which is the result of a computed userset
    ///    value in the authorization model
    /// - a tupleToUserset nodes, containing the result of expanding
    ///    a tupleToUserset value in a authorization model.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Leaf {
        #[prost(oneof = "leaf::Value", tags = "1, 2, 3")]
        pub value: ::core::option::Option<leaf::Value>,
    }
    /// Nested message and enum types in `Leaf`.
    pub mod leaf {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            Users(super::Users),
            #[prost(message, tag = "2")]
            Computed(super::Computed),
            #[prost(message, tag = "3")]
            TupleToUserset(super::TupleToUserset),
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Nodes {
        #[prost(message, repeated, tag = "1")]
        pub nodes: ::prost::alloc::vec::Vec<Node>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Users {
        #[prost(string, repeated, tag = "1")]
        pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Computed {
        #[prost(string, tag = "1")]
        pub userset: ::prost::alloc::string::String,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TupleToUserset {
        #[prost(string, tag = "1")]
        pub tupleset: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub computed: ::prost::alloc::vec::Vec<Computed>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Difference {
        #[prost(message, optional, boxed, tag = "1")]
        pub base: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
        #[prost(message, optional, boxed, tag = "2")]
        pub subtract: ::core::option::Option<::prost::alloc::boxed::Box<Node>>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "node::Value", tags = "2, 5, 6, 7")]
        pub value: ::core::option::Option<node::Value>,
    }
    /// Nested message and enum types in `Node`.
    pub mod node {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[serde(rename_all = "camelCase")]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "2")]
            Leaf(super::Leaf),
            #[prost(message, tag = "5")]
            Difference(::prost::alloc::boxed::Box<super::Difference>),
            #[prost(message, tag = "6")]
            Union(super::Nodes),
            #[prost(message, tag = "7")]
            Intersection(super::Nodes),
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TupleChange {
    #[prost(message, optional, tag = "1")]
    pub tuple_key: ::core::option::Option<TupleKey>,
    #[prost(enumeration = "TupleOperation", tag = "2")]
    pub operation: i32,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Store {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub deleted_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserTypeFilter {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
}
/// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TupleOperation {
    Write = 0,
    Delete = 1,
}
impl TupleOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Write => "TUPLE_OPERATION_WRITE",
            Self::Delete => "TUPLE_OPERATION_DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TUPLE_OPERATION_WRITE" => Some(Self::Write),
            "TUPLE_OPERATION_DELETE" => Some(Self::Delete),
            _ => None,
        }
    }
}
/// Controls the consistency preferences when calling the query APIs.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsistencyPreference {
    /// Default if not set. Behavior will be the same as MINIMIZE_LATENCY.
    Unspecified = 0,
    /// Minimize latency at the potential expense of lower consistency.
    MinimizeLatency = 100,
    /// Prefer higher consistency, at the potential expense of increased latency.
    HigherConsistency = 200,
}
impl ConsistencyPreference {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::MinimizeLatency => "MINIMIZE_LATENCY",
            Self::HigherConsistency => "HIGHER_CONSISTENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "MINIMIZE_LATENCY" => Some(Self::MinimizeLatency),
            "HIGHER_CONSISTENCY" => Some(Self::HigherConsistency),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectsRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub contextual_tuples: ::core::option::Option<ContextualTupleKeys>,
    /// Additional request context that will be used to evaluate any ABAC conditions encountered
    /// in the query evaluation.
    #[prost(message, optional, tag = "7")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "8")]
    pub consistency: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListObjectsResponse {
    #[prost(string, repeated, tag = "1")]
    pub objects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub object: ::core::option::Option<Object>,
    #[prost(string, tag = "4")]
    pub relation: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub user_filters: ::prost::alloc::vec::Vec<UserTypeFilter>,
    #[prost(message, repeated, tag = "6")]
    pub contextual_tuples: ::prost::alloc::vec::Vec<TupleKey>,
    /// Additional request context that will be used to evaluate any ABAC conditions encountered
    /// in the query evaluation.
    #[prost(message, optional, tag = "7")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "8")]
    pub consistency: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamedListObjectsRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub contextual_tuples: ::core::option::Option<ContextualTupleKeys>,
    /// Additional request context that will be used to evaluate any ABAC conditions encountered
    /// in the query evaluation.
    #[prost(message, optional, tag = "7")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "8")]
    pub consistency: i32,
}
/// The response for a StreamedListObjects RPC.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamedListObjectsResponse {
    #[prost(string, tag = "1")]
    pub object: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tuple_key: ::core::option::Option<ReadRequestTupleKey>,
    #[prost(message, optional, tag = "3")]
    pub page_size: ::core::option::Option<i32>,
    #[prost(string, tag = "4")]
    pub continuation_token: ::prost::alloc::string::String,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "5")]
    pub consistency: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequestTupleKey {
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub object: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub tuples: ::prost::alloc::vec::Vec<Tuple>,
    #[prost(string, tag = "2")]
    pub continuation_token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequestWrites {
    #[prost(message, repeated, tag = "1")]
    pub tuple_keys: ::prost::alloc::vec::Vec<TupleKey>,
    #[prost(string, tag = "2")]
    pub on_duplicate: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequestDeletes {
    #[prost(message, repeated, tag = "1")]
    pub tuple_keys: ::prost::alloc::vec::Vec<TupleKeyWithoutCondition>,
    #[prost(string, tag = "2")]
    pub on_missing: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub writes: ::core::option::Option<WriteRequestWrites>,
    #[prost(message, optional, tag = "3")]
    pub deletes: ::core::option::Option<WriteRequestDeletes>,
    #[prost(string, tag = "4")]
    pub authorization_model_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tuple_key: ::core::option::Option<CheckRequestTupleKey>,
    #[prost(message, optional, tag = "3")]
    pub contextual_tuples: ::core::option::Option<ContextualTupleKeys>,
    #[prost(string, tag = "4")]
    pub authorization_model_id: ::prost::alloc::string::String,
    /// Defaults to false. Making it true has performance implications.
    #[prost(bool, tag = "5")]
    pub trace: bool,
    /// Additional request context that will be used to evaluate any ABAC conditions encountered
    /// in the query evaluation.
    #[prost(message, optional, tag = "6")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "7")]
    pub consistency: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckRequestTupleKey {
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub object: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckResponse {
    #[prost(bool, tag = "1")]
    pub allowed: bool,
    /// For internal use only.
    #[prost(string, tag = "2")]
    pub resolution: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCheckRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub checks: ::prost::alloc::vec::Vec<BatchCheckItem>,
    #[prost(string, tag = "3")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ConsistencyPreference", tag = "4")]
    pub consistency: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCheckItem {
    #[prost(message, optional, tag = "1")]
    pub tuple_key: ::core::option::Option<CheckRequestTupleKey>,
    #[prost(message, optional, tag = "2")]
    pub contextual_tuples: ::core::option::Option<ContextualTupleKeys>,
    #[prost(message, optional, tag = "3")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
    #[prost(string, tag = "4")]
    pub correlation_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCheckResponse {
    #[prost(map = "string, message", tag = "1")]
    pub result: ::std::collections::HashMap<::prost::alloc::string::String, BatchCheckSingleResult>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCheckSingleResult {
    #[prost(oneof = "batch_check_single_result::CheckResult", tags = "1, 2")]
    pub check_result: ::core::option::Option<batch_check_single_result::CheckResult>,
}
/// Nested message and enum types in `BatchCheckSingleResult`.
pub mod batch_check_single_result {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CheckResult {
        #[prost(bool, tag = "1")]
        Allowed(bool),
        #[prost(message, tag = "2")]
        Error(super::CheckError),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckError {
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(oneof = "check_error::Code", tags = "1, 2")]
    pub code: ::core::option::Option<check_error::Code>,
}
/// Nested message and enum types in `CheckError`.
pub mod check_error {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Code {
        #[prost(enumeration = "super::ErrorCode", tag = "1")]
        InputError(i32),
        #[prost(enumeration = "super::InternalErrorCode", tag = "2")]
        InternalError(i32),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tuple_key: ::core::option::Option<ExpandRequestTupleKey>,
    #[prost(string, tag = "3")]
    pub authorization_model_id: ::prost::alloc::string::String,
    /// Controls the consistency preference for this request. Default value is UNSPECIFIED, which will have the same behavior as MINIMIZE_LATENCY.
    #[prost(enumeration = "ConsistencyPreference", tag = "4")]
    pub consistency: i32,
    #[prost(message, optional, tag = "5")]
    pub contextual_tuples: ::core::option::Option<ContextualTupleKeys>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandRequestTupleKey {
    #[prost(string, tag = "1")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandResponse {
    #[prost(message, optional, tag = "1")]
    pub tree: ::core::option::Option<UsersetTree>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAuthorizationModelRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAuthorizationModelResponse {
    #[prost(message, optional, tag = "1")]
    pub authorization_model: ::core::option::Option<AuthorizationModel>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteAuthorizationModelRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub type_definitions: ::prost::alloc::vec::Vec<TypeDefinition>,
    #[prost(string, tag = "3")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "4")]
    pub conditions: ::std::collections::HashMap<::prost::alloc::string::String, Condition>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteAuthorizationModelResponse {
    #[prost(string, tag = "1")]
    pub authorization_model_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAuthorizationModelsRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page_size: ::core::option::Option<i32>,
    #[prost(string, tag = "3")]
    pub continuation_token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAuthorizationModelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub authorization_models: ::prost::alloc::vec::Vec<AuthorizationModel>,
    #[prost(string, tag = "2")]
    pub continuation_token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteAssertionsRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub assertions: ::prost::alloc::vec::Vec<Assertion>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteAssertionsResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAssertionsRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub authorization_model_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadAssertionsResponse {
    #[prost(string, tag = "1")]
    pub authorization_model_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub assertions: ::prost::alloc::vec::Vec<Assertion>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadChangesRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub page_size: ::core::option::Option<i32>,
    #[prost(string, tag = "4")]
    pub continuation_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadChangesResponse {
    #[prost(message, repeated, tag = "1")]
    pub changes: ::prost::alloc::vec::Vec<TupleChange>,
    #[prost(string, tag = "2")]
    pub continuation_token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStoreResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStoreRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStoreResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStoreRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteStoreResponse {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoreRequest {
    #[prost(string, tag = "1")]
    pub store_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoreResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub updated_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub deleted_at: ::core::option::Option<::prost_wkt_types::Timestamp>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStoresRequest {
    #[prost(message, optional, tag = "1")]
    pub page_size: ::core::option::Option<i32>,
    #[prost(string, tag = "2")]
    pub continuation_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStoresResponse {
    #[prost(message, repeated, tag = "1")]
    pub stores: ::prost::alloc::vec::Vec<Store>,
    #[prost(string, tag = "2")]
    pub continuation_token: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssertionTupleKey {
    #[prost(string, tag = "1")]
    pub object: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub user: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assertion {
    #[prost(message, optional, tag = "1")]
    pub tuple_key: ::core::option::Option<AssertionTupleKey>,
    #[prost(bool, tag = "2")]
    pub expectation: bool,
    #[prost(message, repeated, tag = "3")]
    pub contextual_tuples: ::prost::alloc::vec::Vec<TupleKey>,
    /// Additional request context that will be used to evaluate any ABAC conditions encountered
    /// in the query evaluation.
    #[prost(message, optional, tag = "4")]
    pub context: ::core::option::Option<::prost_wkt_types::Struct>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Assertions {
    #[prost(message, repeated, tag = "1")]
    pub assertions: ::prost::alloc::vec::Vec<Assertion>,
}
/// Generated client implementations.
pub mod open_fga_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct OpenFgaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OpenFgaServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OpenFgaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OpenFgaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OpenFgaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/Read");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "Read"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn write(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/Write");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "Write"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn check(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckRequest>,
        ) -> std::result::Result<tonic::Response<super::CheckResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/Check");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "Check"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_check(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::BatchCheckResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/BatchCheck");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "BatchCheck"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn expand(
            &mut self,
            request: impl tonic::IntoRequest<super::ExpandRequest>,
        ) -> std::result::Result<tonic::Response<super::ExpandResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/Expand");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "Expand"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_authorization_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadAuthorizationModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadAuthorizationModelsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openfga.v1.OpenFGAService/ReadAuthorizationModels",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "ReadAuthorizationModels",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_authorization_model(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadAuthorizationModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadAuthorizationModelResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openfga.v1.OpenFGAService/ReadAuthorizationModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "ReadAuthorizationModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn write_authorization_model(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteAuthorizationModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteAuthorizationModelResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openfga.v1.OpenFGAService/WriteAuthorizationModel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "WriteAuthorizationModel",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn write_assertions(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteAssertionsRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteAssertionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/WriteAssertions");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "WriteAssertions",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_assertions(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadAssertionsRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadAssertionsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/ReadAssertions");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "ReadAssertions",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_changes(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadChangesRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadChangesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/ReadChanges");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "ReadChanges"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_store(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateStoreResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/CreateStore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "CreateStore"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_store(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateStoreResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/UpdateStore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "UpdateStore"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_store(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteStoreResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/DeleteStore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "DeleteStore"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_store(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStoreResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/GetStore");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "GetStore"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_stores(
            &mut self,
            request: impl tonic::IntoRequest<super::ListStoresRequest>,
        ) -> std::result::Result<tonic::Response<super::ListStoresResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/ListStores");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "ListStores"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn streamed_list_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamedListObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamedListObjectsResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/openfga.v1.OpenFGAService/StreamedListObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "openfga.v1.OpenFGAService",
                "StreamedListObjects",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn list_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListObjectsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListObjectsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/ListObjects");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "ListObjects"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::ListUsersResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/openfga.v1.OpenFGAService/ListUsers");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("openfga.v1.OpenFGAService", "ListUsers"));
            self.inner.unary(req, path, codec).await
        }
    }
}

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.AuthorizationModel")]
    impl ::prost_wkt::MessageSerde for AuthorizationModel {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "AuthorizationModel"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.AuthorizationModel"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.AuthorizationModel" , decoder : | buf : & [u8] | { let msg : AuthorizationModel = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for AuthorizationModel {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "AuthorizationModel";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.AuthorizationModel".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TypeDefinition")]
    impl ::prost_wkt::MessageSerde for TypeDefinition {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TypeDefinition"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TypeDefinition"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TypeDefinition" , decoder : | buf : & [u8] | { let msg : TypeDefinition = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TypeDefinition {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TypeDefinition";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TypeDefinition".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Relation")]
    impl ::prost_wkt::MessageSerde for Relation {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Relation"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Relation"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Relation" , decoder : | buf : & [u8] | { let msg : Relation = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Relation {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Relation";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Relation".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.RelationTypeInfo")]
    impl ::prost_wkt::MessageSerde for RelationTypeInfo {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "RelationTypeInfo"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.RelationTypeInfo"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.RelationTypeInfo" , decoder : | buf : & [u8] | { let msg : RelationTypeInfo = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for RelationTypeInfo {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "RelationTypeInfo";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.RelationTypeInfo".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Metadata")]
    impl ::prost_wkt::MessageSerde for Metadata {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Metadata"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Metadata"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Metadata" , decoder : | buf : & [u8] | { let msg : Metadata = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Metadata {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Metadata";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Metadata".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.SourceInfo")]
    impl ::prost_wkt::MessageSerde for SourceInfo {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "SourceInfo"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.SourceInfo"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.SourceInfo" , decoder : | buf : & [u8] | { let msg : SourceInfo = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for SourceInfo {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "SourceInfo";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.SourceInfo".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.RelationMetadata")]
    impl ::prost_wkt::MessageSerde for RelationMetadata {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "RelationMetadata"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.RelationMetadata"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.RelationMetadata" , decoder : | buf : & [u8] | { let msg : RelationMetadata = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for RelationMetadata {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "RelationMetadata";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.RelationMetadata".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.RelationReference")]
    impl ::prost_wkt::MessageSerde for RelationReference {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "RelationReference"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.RelationReference"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.RelationReference" , decoder : | buf : & [u8] | { let msg : RelationReference = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for RelationReference {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "RelationReference";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.RelationReference".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Wildcard")]
    impl ::prost_wkt::MessageSerde for Wildcard {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Wildcard"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Wildcard"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Wildcard" , decoder : | buf : & [u8] | { let msg : Wildcard = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Wildcard {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Wildcard";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Wildcard".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Usersets")]
    impl ::prost_wkt::MessageSerde for Usersets {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Usersets"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Usersets"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Usersets" , decoder : | buf : & [u8] | { let msg : Usersets = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Usersets {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Usersets";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Usersets".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Difference")]
    impl ::prost_wkt::MessageSerde for Difference {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Difference"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Difference"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Difference" , decoder : | buf : & [u8] | { let msg : Difference = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Difference {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Difference";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Difference".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Userset")]
    impl ::prost_wkt::MessageSerde for Userset {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Userset"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Userset"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Userset" , decoder : | buf : & [u8] | { let msg : Userset = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Userset {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Userset";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Userset".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.DirectUserset")]
    impl ::prost_wkt::MessageSerde for DirectUserset {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "DirectUserset"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.DirectUserset"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.DirectUserset" , decoder : | buf : & [u8] | { let msg : DirectUserset = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for DirectUserset {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "DirectUserset";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.DirectUserset".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ObjectRelation")]
    impl ::prost_wkt::MessageSerde for ObjectRelation {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ObjectRelation"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ObjectRelation"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ObjectRelation" , decoder : | buf : & [u8] | { let msg : ObjectRelation = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ObjectRelation {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ObjectRelation";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ObjectRelation".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ComputedUserset")]
    impl ::prost_wkt::MessageSerde for ComputedUserset {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ComputedUserset"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ComputedUserset"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ComputedUserset" , decoder : | buf : & [u8] | { let msg : ComputedUserset = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ComputedUserset {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ComputedUserset";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ComputedUserset".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TupleToUserset")]
    impl ::prost_wkt::MessageSerde for TupleToUserset {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TupleToUserset"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TupleToUserset"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TupleToUserset" , decoder : | buf : & [u8] | { let msg : TupleToUserset = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TupleToUserset {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TupleToUserset";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TupleToUserset".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Condition")]
    impl ::prost_wkt::MessageSerde for Condition {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Condition"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Condition"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Condition" , decoder : | buf : & [u8] | { let msg : Condition = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Condition {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Condition";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Condition".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ConditionMetadata")]
    impl ::prost_wkt::MessageSerde for ConditionMetadata {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ConditionMetadata"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ConditionMetadata"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ConditionMetadata" , decoder : | buf : & [u8] | { let msg : ConditionMetadata = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ConditionMetadata {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ConditionMetadata";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ConditionMetadata".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ConditionParamTypeRef")]
    impl ::prost_wkt::MessageSerde for ConditionParamTypeRef {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ConditionParamTypeRef"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ConditionParamTypeRef"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ConditionParamTypeRef" , decoder : | buf : & [u8] | { let msg : ConditionParamTypeRef = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ConditionParamTypeRef {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ConditionParamTypeRef";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ConditionParamTypeRef".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ValidationErrorMessageResponse")]
    impl ::prost_wkt::MessageSerde for ValidationErrorMessageResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ValidationErrorMessageResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ValidationErrorMessageResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ValidationErrorMessageResponse" , decoder : | buf : & [u8] | { let msg : ValidationErrorMessageResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ValidationErrorMessageResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ValidationErrorMessageResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ValidationErrorMessageResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UnauthenticatedResponse")]
    impl ::prost_wkt::MessageSerde for UnauthenticatedResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UnauthenticatedResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UnauthenticatedResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UnauthenticatedResponse" , decoder : | buf : & [u8] | { let msg : UnauthenticatedResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UnauthenticatedResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UnauthenticatedResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UnauthenticatedResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UnprocessableContentMessageResponse")]
    impl ::prost_wkt::MessageSerde for UnprocessableContentMessageResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UnprocessableContentMessageResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UnprocessableContentMessageResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UnprocessableContentMessageResponse" , decoder : | buf : & [u8] | { let msg : UnprocessableContentMessageResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UnprocessableContentMessageResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UnprocessableContentMessageResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UnprocessableContentMessageResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.InternalErrorMessageResponse")]
    impl ::prost_wkt::MessageSerde for InternalErrorMessageResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "InternalErrorMessageResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.InternalErrorMessageResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.InternalErrorMessageResponse" , decoder : | buf : & [u8] | { let msg : InternalErrorMessageResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for InternalErrorMessageResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "InternalErrorMessageResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.InternalErrorMessageResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.PathUnknownErrorMessageResponse")]
    impl ::prost_wkt::MessageSerde for PathUnknownErrorMessageResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "PathUnknownErrorMessageResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.PathUnknownErrorMessageResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.PathUnknownErrorMessageResponse" , decoder : | buf : & [u8] | { let msg : PathUnknownErrorMessageResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for PathUnknownErrorMessageResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "PathUnknownErrorMessageResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.PathUnknownErrorMessageResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.AbortedMessageResponse")]
    impl ::prost_wkt::MessageSerde for AbortedMessageResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "AbortedMessageResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.AbortedMessageResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.AbortedMessageResponse" , decoder : | buf : & [u8] | { let msg : AbortedMessageResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for AbortedMessageResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "AbortedMessageResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.AbortedMessageResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ErrorMessageRequest")]
    impl ::prost_wkt::MessageSerde for ErrorMessageRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ErrorMessageRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ErrorMessageRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ErrorMessageRequest" , decoder : | buf : & [u8] | { let msg : ErrorMessageRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ErrorMessageRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ErrorMessageRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ErrorMessageRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ForbiddenResponse")]
    impl ::prost_wkt::MessageSerde for ForbiddenResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ForbiddenResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ForbiddenResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ForbiddenResponse" , decoder : | buf : & [u8] | { let msg : ForbiddenResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ForbiddenResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ForbiddenResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ForbiddenResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Object")]
    impl ::prost_wkt::MessageSerde for Object {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Object"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Object"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Object" , decoder : | buf : & [u8] | { let msg : Object = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Object {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Object";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Object".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.User")]
    impl ::prost_wkt::MessageSerde for User {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "User"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.User"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.User" , decoder : | buf : & [u8] | { let msg : User = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for User {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "User";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.User".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UsersetUser")]
    impl ::prost_wkt::MessageSerde for UsersetUser {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UsersetUser"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UsersetUser"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UsersetUser" , decoder : | buf : & [u8] | { let msg : UsersetUser = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UsersetUser {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UsersetUser";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UsersetUser".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.RelationshipCondition")]
    impl ::prost_wkt::MessageSerde for RelationshipCondition {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "RelationshipCondition"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.RelationshipCondition"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.RelationshipCondition" , decoder : | buf : & [u8] | { let msg : RelationshipCondition = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for RelationshipCondition {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "RelationshipCondition";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.RelationshipCondition".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TupleKeyWithoutCondition")]
    impl ::prost_wkt::MessageSerde for TupleKeyWithoutCondition {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TupleKeyWithoutCondition"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TupleKeyWithoutCondition"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TupleKeyWithoutCondition" , decoder : | buf : & [u8] | { let msg : TupleKeyWithoutCondition = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TupleKeyWithoutCondition {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TupleKeyWithoutCondition";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TupleKeyWithoutCondition".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TypedWildcard")]
    impl ::prost_wkt::MessageSerde for TypedWildcard {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TypedWildcard"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TypedWildcard"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TypedWildcard" , decoder : | buf : & [u8] | { let msg : TypedWildcard = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TypedWildcard {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TypedWildcard";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TypedWildcard".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TupleKey")]
    impl ::prost_wkt::MessageSerde for TupleKey {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TupleKey"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TupleKey"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TupleKey" , decoder : | buf : & [u8] | { let msg : TupleKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TupleKey {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TupleKey";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TupleKey".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Tuple")]
    impl ::prost_wkt::MessageSerde for Tuple {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Tuple"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Tuple"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Tuple" , decoder : | buf : & [u8] | { let msg : Tuple = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Tuple {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Tuple";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Tuple".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TupleKeys")]
    impl ::prost_wkt::MessageSerde for TupleKeys {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TupleKeys"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TupleKeys"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TupleKeys" , decoder : | buf : & [u8] | { let msg : TupleKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TupleKeys {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TupleKeys";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TupleKeys".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ContextualTupleKeys")]
    impl ::prost_wkt::MessageSerde for ContextualTupleKeys {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ContextualTupleKeys"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ContextualTupleKeys"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ContextualTupleKeys" , decoder : | buf : & [u8] | { let msg : ContextualTupleKeys = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ContextualTupleKeys {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ContextualTupleKeys";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ContextualTupleKeys".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UsersetTree")]
    impl ::prost_wkt::MessageSerde for UsersetTree {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UsersetTree"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UsersetTree"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UsersetTree" , decoder : | buf : & [u8] | { let msg : UsersetTree = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UsersetTree {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UsersetTree";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UsersetTree".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.TupleChange")]
    impl ::prost_wkt::MessageSerde for TupleChange {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "TupleChange"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.TupleChange"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.TupleChange" , decoder : | buf : & [u8] | { let msg : TupleChange = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for TupleChange {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "TupleChange";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.TupleChange".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Store")]
    impl ::prost_wkt::MessageSerde for Store {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Store"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Store"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Store" , decoder : | buf : & [u8] | { let msg : Store = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Store {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Store";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Store".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UserTypeFilter")]
    impl ::prost_wkt::MessageSerde for UserTypeFilter {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UserTypeFilter"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UserTypeFilter"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UserTypeFilter" , decoder : | buf : & [u8] | { let msg : UserTypeFilter = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UserTypeFilter {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UserTypeFilter";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UserTypeFilter".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListObjectsRequest")]
    impl ::prost_wkt::MessageSerde for ListObjectsRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListObjectsRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListObjectsRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListObjectsRequest" , decoder : | buf : & [u8] | { let msg : ListObjectsRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListObjectsRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListObjectsRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListObjectsRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListObjectsResponse")]
    impl ::prost_wkt::MessageSerde for ListObjectsResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListObjectsResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListObjectsResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListObjectsResponse" , decoder : | buf : & [u8] | { let msg : ListObjectsResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListObjectsResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListObjectsResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListObjectsResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListUsersRequest")]
    impl ::prost_wkt::MessageSerde for ListUsersRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListUsersRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListUsersRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListUsersRequest" , decoder : | buf : & [u8] | { let msg : ListUsersRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListUsersRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListUsersRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListUsersRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListUsersResponse")]
    impl ::prost_wkt::MessageSerde for ListUsersResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListUsersResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListUsersResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListUsersResponse" , decoder : | buf : & [u8] | { let msg : ListUsersResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListUsersResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListUsersResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListUsersResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.StreamedListObjectsRequest")]
    impl ::prost_wkt::MessageSerde for StreamedListObjectsRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "StreamedListObjectsRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.StreamedListObjectsRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.StreamedListObjectsRequest" , decoder : | buf : & [u8] | { let msg : StreamedListObjectsRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for StreamedListObjectsRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "StreamedListObjectsRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.StreamedListObjectsRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.StreamedListObjectsResponse")]
    impl ::prost_wkt::MessageSerde for StreamedListObjectsResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "StreamedListObjectsResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.StreamedListObjectsResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.StreamedListObjectsResponse" , decoder : | buf : & [u8] | { let msg : StreamedListObjectsResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for StreamedListObjectsResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "StreamedListObjectsResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.StreamedListObjectsResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadRequest")]
    impl ::prost_wkt::MessageSerde for ReadRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadRequest" , decoder : | buf : & [u8] | { let msg : ReadRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadRequestTupleKey")]
    impl ::prost_wkt::MessageSerde for ReadRequestTupleKey {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadRequestTupleKey"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadRequestTupleKey"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadRequestTupleKey" , decoder : | buf : & [u8] | { let msg : ReadRequestTupleKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadRequestTupleKey {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadRequestTupleKey";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadRequestTupleKey".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadResponse")]
    impl ::prost_wkt::MessageSerde for ReadResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadResponse" , decoder : | buf : & [u8] | { let msg : ReadResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteRequestWrites")]
    impl ::prost_wkt::MessageSerde for WriteRequestWrites {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteRequestWrites"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteRequestWrites"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteRequestWrites" , decoder : | buf : & [u8] | { let msg : WriteRequestWrites = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteRequestWrites {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteRequestWrites";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteRequestWrites".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteRequestDeletes")]
    impl ::prost_wkt::MessageSerde for WriteRequestDeletes {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteRequestDeletes"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteRequestDeletes"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteRequestDeletes" , decoder : | buf : & [u8] | { let msg : WriteRequestDeletes = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteRequestDeletes {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteRequestDeletes";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteRequestDeletes".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteRequest")]
    impl ::prost_wkt::MessageSerde for WriteRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteRequest" , decoder : | buf : & [u8] | { let msg : WriteRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteResponse")]
    impl ::prost_wkt::MessageSerde for WriteResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteResponse" , decoder : | buf : & [u8] | { let msg : WriteResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CheckRequest")]
    impl ::prost_wkt::MessageSerde for CheckRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CheckRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CheckRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CheckRequest" , decoder : | buf : & [u8] | { let msg : CheckRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CheckRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CheckRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CheckRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CheckRequestTupleKey")]
    impl ::prost_wkt::MessageSerde for CheckRequestTupleKey {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CheckRequestTupleKey"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CheckRequestTupleKey"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CheckRequestTupleKey" , decoder : | buf : & [u8] | { let msg : CheckRequestTupleKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CheckRequestTupleKey {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CheckRequestTupleKey";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CheckRequestTupleKey".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CheckResponse")]
    impl ::prost_wkt::MessageSerde for CheckResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CheckResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CheckResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CheckResponse" , decoder : | buf : & [u8] | { let msg : CheckResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CheckResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CheckResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CheckResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.BatchCheckRequest")]
    impl ::prost_wkt::MessageSerde for BatchCheckRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "BatchCheckRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.BatchCheckRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.BatchCheckRequest" , decoder : | buf : & [u8] | { let msg : BatchCheckRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for BatchCheckRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "BatchCheckRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.BatchCheckRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.BatchCheckItem")]
    impl ::prost_wkt::MessageSerde for BatchCheckItem {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "BatchCheckItem"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.BatchCheckItem"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.BatchCheckItem" , decoder : | buf : & [u8] | { let msg : BatchCheckItem = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for BatchCheckItem {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "BatchCheckItem";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.BatchCheckItem".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.BatchCheckResponse")]
    impl ::prost_wkt::MessageSerde for BatchCheckResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "BatchCheckResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.BatchCheckResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.BatchCheckResponse" , decoder : | buf : & [u8] | { let msg : BatchCheckResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for BatchCheckResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "BatchCheckResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.BatchCheckResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.BatchCheckSingleResult")]
    impl ::prost_wkt::MessageSerde for BatchCheckSingleResult {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "BatchCheckSingleResult"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.BatchCheckSingleResult"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.BatchCheckSingleResult" , decoder : | buf : & [u8] | { let msg : BatchCheckSingleResult = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for BatchCheckSingleResult {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "BatchCheckSingleResult";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.BatchCheckSingleResult".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CheckError")]
    impl ::prost_wkt::MessageSerde for CheckError {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CheckError"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CheckError"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CheckError" , decoder : | buf : & [u8] | { let msg : CheckError = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CheckError {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CheckError";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CheckError".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ExpandRequest")]
    impl ::prost_wkt::MessageSerde for ExpandRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ExpandRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ExpandRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ExpandRequest" , decoder : | buf : & [u8] | { let msg : ExpandRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ExpandRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ExpandRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ExpandRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ExpandRequestTupleKey")]
    impl ::prost_wkt::MessageSerde for ExpandRequestTupleKey {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ExpandRequestTupleKey"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ExpandRequestTupleKey"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ExpandRequestTupleKey" , decoder : | buf : & [u8] | { let msg : ExpandRequestTupleKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ExpandRequestTupleKey {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ExpandRequestTupleKey";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ExpandRequestTupleKey".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ExpandResponse")]
    impl ::prost_wkt::MessageSerde for ExpandResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ExpandResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ExpandResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ExpandResponse" , decoder : | buf : & [u8] | { let msg : ExpandResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ExpandResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ExpandResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ExpandResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAuthorizationModelRequest")]
    impl ::prost_wkt::MessageSerde for ReadAuthorizationModelRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAuthorizationModelRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAuthorizationModelRequest" , decoder : | buf : & [u8] | { let msg : ReadAuthorizationModelRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAuthorizationModelRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAuthorizationModelRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAuthorizationModelResponse")]
    impl ::prost_wkt::MessageSerde for ReadAuthorizationModelResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAuthorizationModelResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAuthorizationModelResponse" , decoder : | buf : & [u8] | { let msg : ReadAuthorizationModelResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAuthorizationModelResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAuthorizationModelResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteAuthorizationModelRequest")]
    impl ::prost_wkt::MessageSerde for WriteAuthorizationModelRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteAuthorizationModelRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteAuthorizationModelRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteAuthorizationModelRequest" , decoder : | buf : & [u8] | { let msg : WriteAuthorizationModelRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteAuthorizationModelRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteAuthorizationModelRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteAuthorizationModelRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteAuthorizationModelResponse")]
    impl ::prost_wkt::MessageSerde for WriteAuthorizationModelResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteAuthorizationModelResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteAuthorizationModelResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteAuthorizationModelResponse" , decoder : | buf : & [u8] | { let msg : WriteAuthorizationModelResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteAuthorizationModelResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteAuthorizationModelResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteAuthorizationModelResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAuthorizationModelsRequest")]
    impl ::prost_wkt::MessageSerde for ReadAuthorizationModelsRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAuthorizationModelsRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelsRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAuthorizationModelsRequest" , decoder : | buf : & [u8] | { let msg : ReadAuthorizationModelsRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAuthorizationModelsRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAuthorizationModelsRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelsRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAuthorizationModelsResponse")]
    impl ::prost_wkt::MessageSerde for ReadAuthorizationModelsResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAuthorizationModelsResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelsResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAuthorizationModelsResponse" , decoder : | buf : & [u8] | { let msg : ReadAuthorizationModelsResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAuthorizationModelsResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAuthorizationModelsResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAuthorizationModelsResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteAssertionsRequest")]
    impl ::prost_wkt::MessageSerde for WriteAssertionsRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteAssertionsRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteAssertionsRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteAssertionsRequest" , decoder : | buf : & [u8] | { let msg : WriteAssertionsRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteAssertionsRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteAssertionsRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteAssertionsRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.WriteAssertionsResponse")]
    impl ::prost_wkt::MessageSerde for WriteAssertionsResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "WriteAssertionsResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.WriteAssertionsResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.WriteAssertionsResponse" , decoder : | buf : & [u8] | { let msg : WriteAssertionsResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for WriteAssertionsResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "WriteAssertionsResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.WriteAssertionsResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAssertionsRequest")]
    impl ::prost_wkt::MessageSerde for ReadAssertionsRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAssertionsRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAssertionsRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAssertionsRequest" , decoder : | buf : & [u8] | { let msg : ReadAssertionsRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAssertionsRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAssertionsRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAssertionsRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadAssertionsResponse")]
    impl ::prost_wkt::MessageSerde for ReadAssertionsResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadAssertionsResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadAssertionsResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadAssertionsResponse" , decoder : | buf : & [u8] | { let msg : ReadAssertionsResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadAssertionsResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadAssertionsResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadAssertionsResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadChangesRequest")]
    impl ::prost_wkt::MessageSerde for ReadChangesRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadChangesRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadChangesRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadChangesRequest" , decoder : | buf : & [u8] | { let msg : ReadChangesRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadChangesRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadChangesRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadChangesRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ReadChangesResponse")]
    impl ::prost_wkt::MessageSerde for ReadChangesResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ReadChangesResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ReadChangesResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ReadChangesResponse" , decoder : | buf : & [u8] | { let msg : ReadChangesResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ReadChangesResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ReadChangesResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ReadChangesResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CreateStoreRequest")]
    impl ::prost_wkt::MessageSerde for CreateStoreRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CreateStoreRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CreateStoreRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CreateStoreRequest" , decoder : | buf : & [u8] | { let msg : CreateStoreRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CreateStoreRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CreateStoreRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CreateStoreRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.CreateStoreResponse")]
    impl ::prost_wkt::MessageSerde for CreateStoreResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "CreateStoreResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.CreateStoreResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.CreateStoreResponse" , decoder : | buf : & [u8] | { let msg : CreateStoreResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for CreateStoreResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "CreateStoreResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.CreateStoreResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UpdateStoreRequest")]
    impl ::prost_wkt::MessageSerde for UpdateStoreRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UpdateStoreRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UpdateStoreRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UpdateStoreRequest" , decoder : | buf : & [u8] | { let msg : UpdateStoreRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UpdateStoreRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UpdateStoreRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UpdateStoreRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.UpdateStoreResponse")]
    impl ::prost_wkt::MessageSerde for UpdateStoreResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "UpdateStoreResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.UpdateStoreResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.UpdateStoreResponse" , decoder : | buf : & [u8] | { let msg : UpdateStoreResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for UpdateStoreResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "UpdateStoreResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.UpdateStoreResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.DeleteStoreRequest")]
    impl ::prost_wkt::MessageSerde for DeleteStoreRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "DeleteStoreRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.DeleteStoreRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.DeleteStoreRequest" , decoder : | buf : & [u8] | { let msg : DeleteStoreRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for DeleteStoreRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "DeleteStoreRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.DeleteStoreRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.DeleteStoreResponse")]
    impl ::prost_wkt::MessageSerde for DeleteStoreResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "DeleteStoreResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.DeleteStoreResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.DeleteStoreResponse" , decoder : | buf : & [u8] | { let msg : DeleteStoreResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for DeleteStoreResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "DeleteStoreResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.DeleteStoreResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.GetStoreRequest")]
    impl ::prost_wkt::MessageSerde for GetStoreRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "GetStoreRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.GetStoreRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.GetStoreRequest" , decoder : | buf : & [u8] | { let msg : GetStoreRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for GetStoreRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "GetStoreRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.GetStoreRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.GetStoreResponse")]
    impl ::prost_wkt::MessageSerde for GetStoreResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "GetStoreResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.GetStoreResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.GetStoreResponse" , decoder : | buf : & [u8] | { let msg : GetStoreResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for GetStoreResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "GetStoreResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.GetStoreResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListStoresRequest")]
    impl ::prost_wkt::MessageSerde for ListStoresRequest {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListStoresRequest"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListStoresRequest"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListStoresRequest" , decoder : | buf : & [u8] | { let msg : ListStoresRequest = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListStoresRequest {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListStoresRequest";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListStoresRequest".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.ListStoresResponse")]
    impl ::prost_wkt::MessageSerde for ListStoresResponse {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "ListStoresResponse"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.ListStoresResponse"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.ListStoresResponse" , decoder : | buf : & [u8] | { let msg : ListStoresResponse = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for ListStoresResponse {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "ListStoresResponse";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.ListStoresResponse".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.AssertionTupleKey")]
    impl ::prost_wkt::MessageSerde for AssertionTupleKey {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "AssertionTupleKey"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.AssertionTupleKey"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.AssertionTupleKey" , decoder : | buf : & [u8] | { let msg : AssertionTupleKey = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for AssertionTupleKey {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "AssertionTupleKey";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.AssertionTupleKey".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Assertion")]
    impl ::prost_wkt::MessageSerde for Assertion {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Assertion"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Assertion"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Assertion" , decoder : | buf : & [u8] | { let msg : Assertion = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Assertion {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Assertion";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Assertion".to_string()
        }
    }
};

#[allow(dead_code)]
const _: () = {
    use ::prost_wkt::typetag;
    #[typetag::serde(name = "type.googleapis.com/openfga.v1.Assertions")]
    impl ::prost_wkt::MessageSerde for Assertions {
        fn package_name(&self) -> &'static str {
            "openfga.v1"
        }
        fn message_name(&self) -> &'static str {
            "Assertions"
        }
        fn type_url(&self) -> &'static str {
            "type.googleapis.com/openfga.v1.Assertions"
        }
        fn new_instance(
            &self,
            data: Vec<u8>,
        ) -> ::std::result::Result<Box<dyn ::prost_wkt::MessageSerde>, ::prost::DecodeError>
        {
            let mut target = Self::default();
            ::prost::Message::merge(&mut target, data.as_slice())?;
            let erased: ::std::boxed::Box<dyn ::prost_wkt::MessageSerde> =
                ::std::boxed::Box::new(target);
            Ok(erased)
        }
        fn try_encoded(&self) -> ::std::result::Result<::std::vec::Vec<u8>, ::prost::EncodeError> {
            let mut buf = ::std::vec::Vec::with_capacity(::prost::Message::encoded_len(self));
            ::prost::Message::encode(self, &mut buf)?;
            Ok(buf)
        }
    }
    ::prost_wkt::inventory::submit! { :: prost_wkt :: MessageSerdeDecoderEntry { type_url : "type.googleapis.com/openfga.v1.Assertions" , decoder : | buf : & [u8] | { let msg : Assertions = :: prost :: Message :: decode (buf) ? ; Ok (:: std :: boxed :: Box :: new (msg)) } } }
    impl ::prost::Name for Assertions {
        const PACKAGE: &'static str = "openfga.v1";
        const NAME: &'static str = "Assertions";
        fn type_url() -> String {
            "type.googleapis.com/openfga.v1.Assertions".to_string()
        }
    }
};
